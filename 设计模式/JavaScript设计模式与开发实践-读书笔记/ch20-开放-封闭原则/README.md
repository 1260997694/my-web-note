### 第20章 开放-封闭原则

在面向对象的程序设计中，开放封闭原则(OCP)是最重要的一条原则。很多时候，一个程序具有良好的设计，往往说明它是符合开放封闭原则的。

开放封闭原则最早由 Eiffel 语言的设计者 Bertrand Meyer 在其著作 Object-Oriented Software Construction 中提出。它的定义如下:

>> 软件实体(类、模块、函数)等应该是可以扩展的，但是不可修改。

#### 找出变化的地方
开放-封闭原则是一个看起来比较虚幻的原则，并没有实际的模板教导我们怎样亦步亦趋地 实现它。但我们还是能找到一些让程序尽量遵守开放封闭原则的规律，最明显的就是找出程序 中将要发生变化的地方，然后把变化封装起来。

通过封装变化的方式，可以把系统中稳定不变的部分和容易变化的部分隔离开来。在系统的 演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经被封装好的，那么替换 起来也相对容易。而变化部分之外的就是稳定的部分。在系统的演变过程中，稳定的部分是不需 要改变的。

#### 设计模式中的开放-封闭原则

1. 发布-订阅模式
发布-订阅模式用来降低多个对象之间的依赖关系，它可以取代对象之间硬编码的通知机制， 一个对象不用再显式地调用另外一个对象的某个接口。当有新的订阅者出现时，发布者的代码不 需要进行任何修改;同样当发布者需要改变时，也不会影响到之前的订阅者。

2. 模板方法模式
模板方法模式是一种典型的通过封装变化来提高系统扩展性的设计模式。在一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以 我们把这部分逻辑抽出来放到父类的模板方法里面;而子类的方法具体怎么实现则是可变的，于 是把这部分变化的逻辑封装到子类中。通过增加新的子类，便能给系统增加新的功能，并不需要 改动抽象父类以及其他的子类，这也是符合开放封闭原则的。

3. 策略模式 
策略模式和模板方法模式是一对竞争者。在大多数情况下，它们可以相互替换使用。模板方法模式基于继承的思想，而策略模式则偏重于组合和委托。
策略模式将各种算法都封装成单独的策略类，这些策略类可以被交换使用。策略和使用策略 的客户代码可以分别独立进行修改而互不影响。我们增加一个新的策略类也非常方便，完全不用修改之前的代码。

4. 代理模式
我们在第 6 章中举了几个例子，开放封闭原则在它们之中都得到了体现。拿预加载图片举例，我们现在已有一个给图片设置 src 的函数 myImage，当我们想为它增加图片预加载功能时，一种做法是改动 myImage 函数内部的代码，更好的做法是提供一个代理函数 proxyMyImage，代理 函数负责图片预加载，在图片预加载完成之后，再将请求转交给原来的 myImage 函数，myImage 在 这个过程中不需要任何改动。

预加载图片的功能和给图片设置 src 的功能被隔离在两个函数里，它们可以单独改变而互不 影响。myImage 不知晓代理的存在，它可以继续专注于自己的职责——给图片设置 src。

#### 开放-封闭原则的相对性

实际上，让程序保持完全封闭是不容易做到的。就算技术上做得到，也需要花费太多的时间 和精力。而且让程序符合开放-封闭原则的代价是引入更多的抽象层次，更多的抽象有可能会增 大代码的复杂度。

更何况，有一些代码是无论如何也不能完全封闭的，总会存在一些无法对其封闭的变化。作 为程序员，我们可以做到的有下面两点：

1. 挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化。
2. 在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。拿一个开源库来说，修改它提供的配置文件，总比修改它的源代码来得简单。

#### 接受第一次愚弄
下面这段话引自 Bob 大叔的《敏捷软件开发原则、模式与实践》。

>> 有句古老的谚语说:“愚弄我一次，应该羞愧的是你。再次愚弄我，应该羞愧的是 我。”这也是一种有效的对待软件设计的态度。为了防止软件背着不必要的复杂性，我们会允许自己被愚弄一次。

让程序一开始就尽量遵守开放封闭原则，并不是一件很容易的事情。一方面，我们需要尽快知道程序在哪些地方会发生变化，这要求我们有一些“未卜先知”的能力。另一方面，留给程序员的需求排期并不是无限的，所以我们可以说服自己去接受不合理的代码带来的第一次愚弄。 
在最初编写代码的时候，先假设变化永远不会发生，这有利于我们迅速完成需求。当变化发生并 且对我们接下来的工作造成影响的时候，可以再回过头来封装这些变化的地方。然后确保我们不 会掉进同一个坑里，这有点像星矢说的:“圣斗士不会被同样的招数击倒第二次。”
