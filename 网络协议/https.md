# HTTPS学习

## 对称加密和非对称加密（相关知识）
### 对称加密（共享秘钥加密）   
定义： 使用加密解密的秘钥一样。  
常见的算法有：DES，AES等。  
优缺点： 对称加密相比较非对称加密来说，加解密效率要高得多，加密速度快。但是缺陷在于对称加密的秘钥管理和分发上比较困难，非常不安全。

### 非对称加密（公开密钥加密）  
定义：使用加密和解密的秘钥不一样。通信两端AB都有一对秘钥，公钥和私钥，A私钥加密的内容只有A公钥可以解开。A公钥一般是分发给B，这里会存在公钥认证问题，需要第三方进行公证B收到的公钥是来自A。同理，A公钥加密的内容只有A私钥能解开。
常见的算法有：RSA等。
优缺点：安全性高，公钥是公开的，私钥自己保存。缺点：加密和解密花费时间长，速度慢，只适合对少量数据进行加密。

### 总结
对称加密效率高，安全性不好，非对称加密安全性好，效率不高    

两者联合使用：既然非对称加密是安全的，我们可以使用非对称加密将对称加密的秘钥分发给客户端，之后再使用对称加密来通信。这就是混合加密算法。

## HTTPS 出现背景
HTTP缺点：
1. 明文传输，而且能被传输路途中任意设备窃听
2. 服务器和客户端之间无法认证真实身份，容易被伪装
3. 数据完整性保护上不够便捷和可靠
HTTPS的出现就是为解决这几个问题。

## HTTPS 定义
HTTPS = HTTP + 加密 + 认证 + 数据完整性保护

## HTTPS 加密机制
采用混合加密算法，综合利用对称加密的效率高和非对称加密的安全性，首先使用‘非对称加密’来分发‘对称加密’的秘钥，之后的通信都使用对称加密来进行。

## HTTPS 原理
![HTTPS原理图](https://raw.githubusercontent.com/zhiwenxuan/My_web_note/master/img/https-principle.png)

### 服务器请求数字证明：  
![证书数字签名](https://user-gold-cdn.xitu.io/2018/5/21/1638197d961729a3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)  

1. 服务器向第三方认证机构CA(Certificate Authority)请求数字证书并将自己的公钥发给认证机构CA  
2. 认证机构用自己的私钥将服务器的公钥和服务器的信息进行加密，形成数字证书，最后颁发给服务器

### 大体流程：  


![HTTPS原理大体流程图](https://raw.githubusercontent.com/zhiwenxuan/My_web_note/master/img/https-short-principle.png)


第一步，浏览器请求公钥，请求报文包含：加密协议版本号（如：TSL1.0）、一个浏览器生成的随机数（Client random），以及浏览器支持的加密方法。

第二步，服务器确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。

第三步，浏览器验证数字证书有效，然后生成一个新的随机数（pre-master secret），并使用数字证书中的公钥，加密这个随机数，发给服务器。

第四步，服务器使用自己的私钥，解密获取客户端发来的随机数（即pre-master secret）。

第五步，客户端和服务器根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程，也就是使用‘对称加密’。

### 客户端验证服务器数字证书原理

#### 关于证书：
服务端向客户端下发自己的证书，通常是CA认证的证书。证书包括了很多信息，主要有“公钥信息”、“签名”、“组织机构地区等信息”、“证书颁发机构”，关联的中级证书(medium certificate)、根证书(root certificate)等。

以百度的证书为例：使用chrome打开百度页面，command+option+j呼出开发者工具在“security”栏目下，点击"View certificate"按钮，可以看到该网站的证书

![zhengshu](http://static.zybuluo.com/blueGhost/avhp5j6lkjfb8o8amly94a7a/ac0b0415c05d3316bb705b132a77520a.png)

1.公钥：baidu.com证书，如图黄色框内为服务器公钥

![gongyao](http://static.zybuluo.com/blueGhost/y6cqb489njpnv45mgqkzpr93/f5184eeab73dd7a2b6b0785a00089865.png)

2.签名，如下图红色框内为baidu.com证书的签名。签名用于证明这个证书所描述的内容是对的，属实的，且没有被攥改过的。

![qianming](http://static.zybuluo.com/blueGhost/1pqkviv74afwewi8hkhcbvz2/54a7225fe62615a41ab067e822108872.png)

#### 客户端如何通过证书确定服务端的身份？

证明下面两点，（然后才可以使用证书上的公钥来加密生成Session key的随机数）  
1. 证明baidu.com这个证书确实是百度的  
2. 证明baidu.com这个证书没有被其他人攥改过  

证书以证书链的形式组织，在颁发证书的时候首先要有根CA机构颁发的根证书，再由根CA机构颁发一个中级CA机构的证书，最后由中级CA机构颁发具体的SSL证书。以百度为例，如下图，"end-user" -> "intermediates" -> "root"形成一条链。 

![证书链](http://static.zybuluo.com/blueGhost/p67ztphnq950pj6j0soh9iaf/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-05%20%E4%B8%8B%E5%8D%889.51.20.png)

数字证书采用信任链验证。数字证书的信任锚（信任的起点）就是根证书颁发机构。根证书（root certificate）是一个无签名或自签名的证书。是用于识别根证书颁发机构（CA）的公钥证书。  

验证的具体实现如下图所示： 

![yangzheng](http://static.zybuluo.com/blueGhost/1odcvxkgk7j77d79t37vd334/Chain_of_trust.svg)

1. 从左往右，用户证书指向签署它的中级证书，并且，用户证书的摘要经由中级证书的私钥加密，密文作为该用户的证书签名(signature)记录在用户证书上。以百度为例，上一节说的签名就是了。
2. 中级证书相应的，指向签署它的根证书，同时，中级证书的摘要经由根证书的私钥加密，密文作为中级证书的签名记录在中级证书上
3. 根证书在签署的时候，使用签发机构的私钥对证书的摘要进行加密，密文作为根证书的签名记录在根证书上。

实际上，根证书甚至可以不签名，因为根证书是预先安装在系统中的，并且由系统保护起来，是值得信赖的。（根证书作为证书信任链的最后一环，非常重要，所以请**不要随便安装不知底细的根证书**）

了解了信任链(trust chain)后，我们可以通过下面的步骤来验证证书：

1. 使用中级证书的公钥对下级证书的签名解密得到下级证书的摘要，由于是RSA解密，能够解密成功说明了下级证书确实是中级证书所签署的（快速脑补一下RSA算法原理）
2. 对下级证书做信息摘要，拿这个摘要与1步骤解密出来的摘要做对比，如果两者一致，则证明了这个下级证书没有被攥改
3. 接着，按照上面1～2步骤，对中级证书进行验证，直到可信任的其他中级证书或者到可信任的根证书（即上溯到一个可信锚点），那么就可以证明这条trust chain上的证书都是正确的可信任的。

好了，现在可以解答这两个问题了：  

1. 证明baidu.com这个证书确实是百度的——通过trust chain，可以验证这个用户证书确实是CA颁发的，而CA给用户颁发证书，已经校验了该用户的资质和情况（比如，确保申请证书的用户确实拥有www.baidu.com站点），并且做了备案
2. 证明baidu.com这个证书没有被其他人攥改过————通过证书链，逐级解密签名得出摘要，通过对比该摘要是否和当前证书的实际摘要相同，确保没有被攥改 

### 利用三个随机数生成会话秘钥的原因
不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。

对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。

pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。

### 小知识点
1. 第三方认证机构在做服务器和客户端之间的公证时使用的加密算法是非对称加密，首先对服务器的公钥使用私钥进行加密形成签名证书，之后客户端会预装好第三方认证机构CA的公钥，最后客户端就可以使用CA的公钥对服务器发过来的签名证书进行加密。因为签名证书是用CA的私钥加密的。  
2. 浏览器会提前预装好认证机构CA的公钥，也叫根证书。  
3. 客户端，服务端各自产生了通信密钥后，就用这个相同的秘钥对往后的所有通信信息进行加密。而这个密钥，第三方是不知道的，第三方尽管去窥探，但是他们看不懂信息，所以效果相当于，客户端&服务端在一个加密信道中通信。  
4. 数字证书：服务器公钥、服务器信息（域名等）、认证机构CA签名，认证机构信息等。  



## HTTPS三次握手

### 握手要解决的问题
1. 客户端和服务器身份的互相确认
2. 协商之后通信中对称加密的秘钥

### 握手流程
![HTTPS三次握手](http://www.ruanyifeng.com/blogimg/asset/201402/bg2014020502.png)

#### 步骤1： 客户端发出请求（ClientHello）
首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。  
在这一步，客户端主要向服务器提供以下信息。  
```
1. 客户端支持的SSL的指定版本
2. 客户端产生的随机数（Client Random, 稍后用于生成"对话密钥"
3. 客户端支持的加密算法
```

#### 步骤2：服务器回应（SeverHello）
服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。  
```
1. 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
2. 一个服务器生成的随机数(Server Random)，稍后用于生成"对话密钥"。
3. 确认使用的加密方法，比如RSA公钥加密。
4. 服务器证书
```
除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"客户端证书"。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。  

**第一次握手结束**  

#### 步骤3：客户端回应
客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。

如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。
```
1. 一个随机数（pre-master key）, 稍后用于生成"对话密钥"。
2. 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
3. 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。
```
上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称"pre-master key"。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。

**第二次握手结束**  

#### 步骤4：服务器的最后回应
服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的"会话密钥"。然后，向客户端最后发送下面信息。  
```
1. 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
2. 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。
```
至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容，也就是对称加密。

**第三次握手结束**  

### 小知识
HTTP耗时 = TCP握手  
HTTPs耗时 = TCP握手 + SSL握手  



## HTTPS 性能优化

### 使用HTTPS相比于HTTP所增加的延迟点
1. HTTP 302 跳转到 HTTPS 的耗时
2. CPU 进行 RSA 加解密运算的耗时
3. 请求和验证 CA 所花的时间

对应的优化方式  

1. 使用 HSTS 技术，去掉从80跳转到443的跳转(HSTS使用的是内部307跳转技术，不会产生多余的网络请求) PS：302 和 307 效果相同，只是307强制使用post
2. 使用专门的加解密硬件处理加解密，减轻CPU负担。这样不仅减少了处理时间，所能承受的qps也会增加。
3. 减少证书链，减少 CA 请求时间
4. session复用，减少建立连接的次数

### HTTPS自身对于性能的优化
1. SSL压缩：除去 HTTP 的数据压缩，SSL 对于数据也有一次压缩，减少了传输时间
2. 使用HTTP/2：要使用HTTP/2就必须要使用 SSL/TLS，HTTPS 显然是最适合使用

#### 使用 HTTP/2 的好处包括但不限于：
1. 多路复用
HTTP 2.0使用多路复用技术，使用一个TCP连接并发处理多个请求，不但节约了开销而且可处理请求的数量也比HTTP 1.1大了很多。

    TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此使用一个连接可以大大提高数据传输效率。

2. 头部压缩
HTTP 1.1不支持header数据压缩，HTTP 2.0使用HPACK算法对header的数据进行压缩，使得数据传输更快。

3. 服务器推送
当我们对支持HTTP 2.0的服务器请求数据额时候，服务器会顺便把一些客户端需要的资源一起推送到服务器，这种方式适用于加载静态资源，节约带宽。


## 可参考文章
[白话解释 对称加密算法 VS 非对称加密算法](https://segmentfault.com/a/1190000004461428)  
[大型网站的HTTPS实践（一）——HTTPS协议和原理](https://mp.weixin.qq.com/s/estsNq9lVrLhR__ShtX22Q)  
[看图学HTTPS](https://juejin.im/post/5b0274ac6fb9a07aaa118f49)  
[HTTPS系列1——HTTPS三次握手](https://www.zybuluo.com/blueGhost/note/805491)  
[SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)  
